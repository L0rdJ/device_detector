<?php
/**
 * @author Chris Abbott, DetectRight Ltd.
 * @package DetectRight
 */
/******************************************************************************
Name:    qdtmessage.class.php
Version: 2.0.0
Config:  default
Author:  Chris Abbott, chris@detectright.com
Support: http://www.detectright.com

© 2012 DetectRight Limited, All Rights Reserved

THIS IS NOT OPEN SOURCE SOFTWARE.

This library's default licencing is under the DetectRight Evaluation License 
Agreement, the latest version of which can be found at 

http://www.detectright.com/legal-and-privacy.html

Use of this library will be deemed to be an acceptance of those terms and conditions,
and must be adhered to unless you have signed a difference license with us (for instance, 
for development, non-profit, social community, OEM, Enterprise or Commercial).

Further details can be found at www.DetectRight.com
**********************************************************************************/

if (class_exists("DetectRight")) {
	DetectRight::registerClass("QDTMessage");
}


/**
 * 
 * A container for a message to a bit of the PropertyCollectionTree
 * maps directly to a single line in the breakdown of a PropertyCollectionTree
 * a Message will generally create a new path through the tree if required
 * This is what's sent through the PropertyCollectionTree to deliver its payload.
 * @author Chris Abbott <chris@detectright.com>
 *
 */
Class QDTMessage {
	/**
	 * State collection associated with the message. Sometimes a message's payload will only consist of a status collection.
	 *
	 * @var StatusCollection
	 */
	public $sc;
	
	/**
	 * Associative array of edits that will be applied at the node. These may also be targeted 
	 * at arbitrary entities or objects.
	 *
	 * @var associative_array(K,V)
	 */
	public $edits; // edits to apply at the destination, keyed by path to create to deliver.
	
	/**
	 * Datapoint objects to deliver to a Quantum data collection.
	 *
	 * @var Datapoint[]
	 */
	public $datapoints=array();
	public $wildcards = array();
	
	/**
	 * The "address" of this message
	 *
	 * @var string
	 */
	public $path="";
	public $brand = ""; // where did this come from?
	
	public $defaultState = "1:50:1";
	public $valid = 1;

	private $ps = array(); // extra messages to deliver generated by the creation of this one.
	
	// e.g. Communicator//Protocol:IEEE:802.15//Component:Bluetooth:*//status=1 with data of 
	function __construct($string,$wildcards=array(),$importanceOffset=0,$brand = "",$validation_type = "") {
		// wildcard could be a wildcard in a path, or a wildcard in a datapoint.
		if (DRFunctionsCore::isEmpty($wildcards)) $wildcards = array();
		$this->sc = new StateCollection();
		$this->datapoints = array();
		$this->edits = array(""=>array());	
		$this->brand = $brand;
		// creates a new QDTMessage from an incoming string
		$string = str_replace("://","{cdbs}",$string);
		$tmp = explode("//",$string);
		$command = array_pop($tmp);
		$this->path = implode("//",$tmp);
		$command = str_replace("{cdbs}","://",$command);
		$this->path = str_replace("{cdbs}","://",$this->path);

		$commands = explode("&/&",$command);
		$commands = $this->sc->extractStates($commands);
		if ($importanceOffset !== 0) {
			$this->sc->addImportance($importanceOffset);
		}

		$importance = $this->sc->getImportance();

		foreach ($wildcards as $wildCardString) {
			if (!DRFunctionsCore::isEmptyStr($validation_type) && $validation_type !== "none") {
				$this->wildcards[] = $this->validateWildcardString($wildCardString,$validation_type,floor($importance*0.75));
			} else {
				$this->wildcards[] = $wildCardString;
			}
		}

		//$this->wildcards = $wildcards;
		$dpWildcards = $this->wildcards;
		$pathWildcards = false;

		// work out what to do with wildcards
		if (!DRFunctionsCore::isEmptyStr($this->path) && substr($this->path,-2,2) === ":*") {
			if (!isset($this->wildcards[0])) {
				// this is a wildcard datapoint with no data. 
				$this->valid = 0;
				$this->path = "";
				return;
			}
			$pathWildcards = true;
			$dpWildcards = array();
			foreach ($this->wildcards as $wildCardString) {
				$this->edits[$wildCardString] = array();
			}
			$this->path = substr($this->path,0,-2);
		} 

		//$invertSC = false;
		foreach ($commands as $command) {
			// work out whether any command is a valid datapointworthy thing
			if (strpos($command,"{") !== false && strpos($command,"}") !== false) {
				// it's a datapoint. Create one for each wildcard.
				// the next line makes sure that even if there are no wildcards, the datapoint
				// gets created: unless it NEEDS wildcards, of course.
				if (!isset($dpWildcards[0])) $dpWildcards[] = "";
				foreach ($dpWildcards as $dpWildcard) {
					$dpWildcard = str_replace(";","\\;",$dpWildcard);
					// next line stops datapoints being created with "*" values if the validation failed 
					// at a previous point. If there's a command with "*" and there's no wildcard, then this
					// is a useless item of data.
					if (strpos($command,"*") !== false && DRFunctionsCore::isEmptyStr($dpWildcard)) continue;
					$datapoint = new Datapoint($command,$dpWildcard);
					if ($datapoint->importance === 0) $datapoint->importance = $importance;
					$this->validateDP($datapoint,floor($importance*0.75));
					$datapoint->importanceOffset = $importanceOffset;
					if ($brand) $datapoint->brand($brand);
					$this->datapoints[] = $datapoint;
				}
			} else {
				// below needs to be dealt with by the import function, ideally.
				/*if ($command === "!status") {
					$command = "status";
					$invertSC = true;
				}*/

				if ($pathWildcards) {
					foreach ($this->wildcards as $wildCardString) {
						$this->edits[$wildCardString][] = $command;
					}
				} else {
					$this->edits[""][] = $command;
				}
			}
		}

		/*if ($this->sc->count() === 0) {
			$this->sc->addStateFromString($this->defaultState);
		}*/
		
		/*if ($invertSC) {
			$this->sc->invert();
		}*/
	}

	public function isPath() {
		if (strpos($this->path,"://") !== false) $map = str_replace("://","{cdbs}",$this->path);
		return (strpos($map,"//") !== false);
	}

	// shifts the path along as it's delivered
	public function shiftPath() {
		$map = str_replace("://","{cdbs}",$this->path);
		$array = explode("//",$this->map);
		$path = array_shift($array);
		if (strpos($map,"{cdbs}") !== false) $map = str_replace("{cdbs}","://",implode("//",$array));
		$this->path = $map;
		return $path;
	}

	public function pkgToPS($pkg,$importance=0) {
		// now alter each returned value to add in current path if prefixed with a "+"
		foreach ($pkg as $pcKey=>$pcValue) {
			if (substr($pcValue,0,1) == "+") {
				$pcValue = substr($pcValue,1);
				if ($this->path !== "") {
					$pkg[$pcKey] = "$this->path//$pcValue";
				} else {
					$tmp = explode("//",$pcValue);
					$branch = array_shift($tmp);
					$tmp = explode(":",$branch);
					$branch = array_shift($tmp);
					$hints = DetectRight::$dbLink->getArray("PathHints");
					$path = DRFunctionsCore::gv($hints,$branch);
					if (DRFunctionsCore::isEmptyStr($path)) $path = "System//";
					if (substr($path,-2,2) !== "//") $path = $path."//";
					$pkg[$pcKey] = $path . $pcValue;
				}
			} 
		}

		if (count($pkg) == 0) return;
		$state = $this->sc->getCollapsedState();
		if ($state === null) {
			$state = State::stateFromString($this->defaultState);
		}
		foreach ($pkg as $string) {
			/*if (!DRFunctionsCore::in("importance",$string)) {
				$string .= "&/&importance->".$importance - 10;
			}*/
			if (!DRFunctionsCore::in("status",$string)) {
				$string .= "&/&status->".$state->getStatus();
			}
			
			// we want to make the new message of importance = this - 20;
			if (!$importance) $importance = $state->getImportance();
			$string .= "&/&importance->$importance";
			$ps = new QDTMessage($string);
			$this->ps[] = $ps;
		}
	}

	public function validateWildcardString($wildcard,$validation_type,$importance=0) {
		$pkg = array();
		$wildcard = Validator::validateWithPC($validation_type,$wildcard,false,$pkg);
		$this->pkgToPS($pkg,$importance);
		return $wildcard;
	}

	// this is the second stage of validation: internal validation and PC getting.
	// a pre-validation may well have been done at SchemaProperty level.
	public function validateDP(&$datapoint,$importance=0) {
		$validation_type = strtolower($datapoint->type);
		if ($validation_type === "none" || DRFunctionsCore::isEmptyStr($validation_type)) {
			return;
		}
		$pkg = array();
		if (!DRFunctionsCore::isEmptyStr($datapoint->value) && strpos($datapoint->value,"*")=== false) {
			$datapoint->value = Validator::validateWithPC($validation_type,$datapoint->value,false,$pkg);
		}
		if ($datapoint->wildcard) {
			$datapoint->wildcard = Validator::validateWithPC($validation_type,$datapoint->wildcard,false,$pkg);
		}
		$this->pkgToPS($pkg,$importance);
		//$datapoint->parseValue();
		$datapoint->validated = true;
	}
	
	public function getExtraMessages() {
		return $this->ps;
	}
	
	public function getEdits() {
		return $this->edits;
	}
	
	public function getDatapoints() {
		return $this->datapoints;
	}
}